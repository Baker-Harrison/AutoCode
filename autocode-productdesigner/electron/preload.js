const { contextBridge, ipcRenderer } = require("electron");

contextBridge.exposeInMainWorld("ide", {
  selectWorkspace: () => ipcRenderer.invoke("workspace:select"),
  getWorkspace: () => ipcRenderer.invoke("workspace:get"),
  listDir: (targetPath) => ipcRenderer.invoke("fs:list", targetPath),
  readFile: (targetPath) => ipcRenderer.invoke("fs:readFile", targetPath),
  writeFile: (payload) => ipcRenderer.invoke("fs:writeFile", payload),
  createFile: (payload) => ipcRenderer.invoke("fs:createFile", payload),
  createDir: (payload) => ipcRenderer.invoke("fs:createDir", payload),
  deletePath: (payload) => ipcRenderer.invoke("fs:delete", payload),
  renamePath: (payload) => ipcRenderer.invoke("fs:rename", payload),
  pathExists: (path) => ipcRenderer.invoke("fs:exists", path),
  revealPath: (path) => ipcRenderer.invoke("fs:revealPath", path),
  refreshFileTree: () => ipcRenderer.invoke("fs:refreshTree"),
  search: (query) => ipcRenderer.invoke("search:run", query),
  startPlanning: (prompt) => ipcRenderer.invoke("planning:start", prompt),
  updateAnswer: (payload) => ipcRenderer.invoke("planning:answer", payload),
  listEvents: (sessionId) => ipcRenderer.invoke("events:list", sessionId),
  clearLogs: () => ipcRenderer.invoke("logs:clear"),
  runCommand: (payload) => ipcRenderer.invoke("run:command", payload),
  listTasks: (sessionId) => ipcRenderer.invoke("tasks:list", sessionId),
  startTerminal: () => ipcRenderer.invoke("terminal:start"),
  createTerminal: (payload) => ipcRenderer.invoke("terminal:create", payload),
  listTerminals: () => ipcRenderer.invoke("terminal:list"),
  renameTerminal: (payload) => ipcRenderer.invoke("terminal:rename", payload),
  killTerminal: (payload) => ipcRenderer.invoke("terminal:kill", payload),
  getAvailableShells: () => ipcRenderer.invoke("terminal:getShells"),
  sendTerminalInput: (payload) => ipcRenderer.send("terminal:input", payload),
  resizeTerminal: (payload) => ipcRenderer.send("terminal:resize", payload),
  disposeTerminal: (payload) => ipcRenderer.send("terminal:dispose", payload),
  onTerminalData: (callback) => {
    const listener = (_event, data) => callback(data);
    ipcRenderer.on("terminal:data", listener);
    return () => {
      ipcRenderer.removeListener("terminal:data", listener);
    };
  },
  gitStatus: (workspace) => ipcRenderer.invoke("git:status", workspace),
  gitStage: (payload) => ipcRenderer.invoke("git:stage", payload),
  gitStageAll: (workspace) => ipcRenderer.invoke("git:stage-all", workspace),
  gitUnstageAll: (workspace) => ipcRenderer.invoke("git:unstage-all", workspace),
  gitUnstage: (payload) => ipcRenderer.invoke("git:unstage", payload),
  gitDiscard: (payload) => ipcRenderer.invoke("git:discard", payload),
  gitCommit: (payload) => ipcRenderer.invoke("git:commit", payload),
  gitDiff: (payload) => ipcRenderer.invoke("git:diff", payload),
  gitStagedDiff: (workspace) => ipcRenderer.invoke("git:staged-diff", workspace),
  gitLog: (payload) => ipcRenderer.invoke("git:log", payload),
  gitBranches: () => ipcRenderer.invoke("git:branches"),
  gitRemoteBranches: () => ipcRenderer.invoke("git:remote-branches"),
  gitCreateBranch: (payload) => ipcRenderer.invoke("git:branch-create", payload),
  gitDeleteBranch: (payload) => ipcRenderer.invoke("git:branch-delete", payload),
  gitRenameBranch: (payload) => ipcRenderer.invoke("git:branch-rename", payload),
  gitCheckoutBranch: (payload) => ipcRenderer.invoke("git:branch-checkout", payload),
  gitMerge: (payload) => ipcRenderer.invoke("git:merge", payload),
  gitRebase: (payload) => ipcRenderer.invoke("git:rebase", payload),
  gitAbortRebase: (workspace) => ipcRenderer.invoke("git:rebase-abort", workspace),
  gitContinueRebase: (workspace) => ipcRenderer.invoke("git:rebase-continue", workspace),
  gitFetch: (workspace) => ipcRenderer.invoke("git:fetch", workspace),
  gitPull: (payload) => ipcRenderer.invoke("git:pull", payload),
  gitPush: (payload) => ipcRenderer.invoke("git:push", payload),
  gitRemotes: () => ipcRenderer.invoke("git:remotes"),
  gitAddRemote: (payload) => ipcRenderer.invoke("git:remote-add", payload),
  gitRemoveRemote: (payload) => ipcRenderer.invoke("git:remote-remove", payload),
  gitIsRepo: (workspace) => ipcRenderer.invoke("git:is-repo", workspace),
  gitInit: () => ipcRenderer.invoke("git:init"),
  gitLastCommitMessage: (workspace) => ipcRenderer.invoke("git:last-commit-message", workspace),
  gitCommitDetails: (hash, workspace) => ipcRenderer.invoke("git:commit-details", hash, workspace),
  gitDiffBranches: (branch1, branch2, workspace) => ipcRenderer.invoke("git:diff-branches", branch1, branch2, workspace),
  memorySearch: (payload) => ipcRenderer.invoke("memory:search", payload),
  memoryInsert: (payload) => ipcRenderer.invoke("memory:insert", payload),
  memoryDelete: (payload) => ipcRenderer.invoke("memory:delete", payload),
  memoryDeleteByQuery: (payload) => ipcRenderer.invoke("memory:deleteByQuery", payload),
  memoryPreload: () => ipcRenderer.invoke("memory:preload"),
  memoryList: (area) => ipcRenderer.invoke("memory:list", area),
  memoryGetById: (id) => ipcRenderer.invoke("memory:getById", id),
  memoryStats: () => ipcRenderer.invoke("memory:stats"),
  memoryAreas: () => ipcRenderer.invoke("memory:areas"),
  listTeams: () => ipcRenderer.invoke("team:list"),
  createTeam: (payload) => ipcRenderer.invoke("team:create", payload),
  listTeamBranches: (payload) => ipcRenderer.invoke("team:list-branches", payload),
  createTeamBranch: (payload) => ipcRenderer.invoke("team:create-branch", payload),
  createTeamPR: (payload) => ipcRenderer.invoke("team:create-pr", payload),
  mergeTeamPR: (payload) => ipcRenderer.invoke("team:merge-pr", payload),
  listTeamCommits: (payload) => ipcRenderer.invoke("team:list-commits", payload),
  listTeamPRs: (payload) => ipcRenderer.invoke("team:list-prs", payload),
  buildPrompt: (options) => ipcRenderer.invoke("prompt:build", options),
  getPromptFiles: () => ipcRenderer.invoke("prompt:list"),
  readPromptFile: (path) => ipcRenderer.invoke("prompt:read", path),
  writePromptFile: (payload) => ipcRenderer.invoke("prompt:write", payload),
  createProjectDirectory: (name) => ipcRenderer.invoke("prompt:createProject", name),
  pluginList: () => ipcRenderer.invoke("plugin:list"),
  pluginGet: (pluginId) => ipcRenderer.invoke("plugin:get", pluginId),
  pluginActivate: (pluginId) => ipcRenderer.invoke("plugin:activate", pluginId),
  pluginDeactivate: (pluginId) => ipcRenderer.invoke("plugin:deactivate", pluginId),
  pluginInstall: (manifestUrl) => ipcRenderer.invoke("plugin:install", manifestUrl),
  pluginUninstall: (pluginId) => ipcRenderer.invoke("plugin:uninstall", pluginId),
  pluginUpdate: (pluginId) => ipcRenderer.invoke("plugin:update", pluginId),
  pluginGetHooks: () => ipcRenderer.invoke("plugin:get-hooks"),
  pluginGetTools: () => ipcRenderer.invoke("plugin:get-tools"),
  pluginGetInstruments: () => ipcRenderer.invoke("plugin:get-instruments"),
  pluginGetActivePlugins: () => ipcRenderer.invoke("plugin:get-active"),
  approvalAssessRisk: (payload) => ipcRenderer.invoke("approval:assessRisk", payload),
  approvalCreate: (payload) => ipcRenderer.invoke("approval:create", payload),
  approvalApprove: (payload) => ipcRenderer.invoke("approval:approve", payload),
  approvalReject: (payload) => ipcRenderer.invoke("approval:reject", payload),
  approvalEscalate: (payload) => ipcRenderer.invoke("approval:escalate", payload),
  approvalGetPending: (limit) => ipcRenderer.invoke("approval:getPending", limit),
  approvalGetHistory: (filters) => ipcRenderer.invoke("approval:getHistory", filters),
  approvalGetEscalations: (filters) => ipcRenderer.invoke("approval:getEscalations", filters),
  approvalResolveEscalation: (escalationId) => ipcRenderer.invoke("approval:resolveEscalation", escalationId),
  approvalGetRules: () => ipcRenderer.invoke("approval:getRules"),
  approvalCreateRule: (payload) => ipcRenderer.invoke("approval:createRule", payload),
  approvalUpdateRule: (payload) => ipcRenderer.invoke("approval:updateRule", payload),
  approvalDeleteRule: (ruleId) => ipcRenderer.invoke("approval:deleteRule", ruleId),
  approvalGetBundle: (bundleId) => ipcRenderer.invoke("approval:getBundle", bundleId),
  approvalBulkApprove: (payload) => ipcRenderer.invoke("approval:bulkApprove", payload),
  approvalBulkReject: (payload) => ipcRenderer.invoke("approval:bulkReject", payload),
  approvalGetRiskLevels: () => ipcRenderer.invoke("approval:getRiskLevels"),
  workflowCreateSession: (prompt) => ipcRenderer.invoke("workflow:createSession", prompt),
  workflowCreateTask: (payload) => ipcRenderer.invoke("workflow:createTask", payload),
  workflowGetTasks: (sessionId) => ipcRenderer.invoke("workflow:getTasks", sessionId),
  workflowUpdateTaskStatus: (taskId, status) => ipcRenderer.invoke("workflow:updateTaskStatus", taskId, status),
  workflowPauseTask: (taskId) => ipcRenderer.invoke("workflow:pauseTask", taskId),
  workflowResumeTask: (taskId) => ipcRenderer.invoke("workflow:resumeTask", taskId),
  workflowRegisterAgent: (agentId, config) => ipcRenderer.invoke("workflow:registerAgent", agentId, config),
  workflowUpdateAgentStatus: (agentId, status, currentTaskId) => ipcRenderer.invoke("workflow:updateAgentStatus", agentId, status, currentTaskId),
  workflowAddMonologue: (agentId, message) => ipcRenderer.invoke("workflow:addMonologue", agentId, message),
  workflowGetMonologue: (agentId, limit) => ipcRenderer.invoke("workflow:getMonologue", agentId, limit),
  workflowRecordToolExecution: (toolName, status, result, metadata) => ipcRenderer.invoke("workflow:recordToolExecution", toolName, status, result, metadata),
  workflowUpdateToolExecution: (executionId, status, result) => ipcRenderer.invoke("workflow:updateToolExecution", executionId, status, result),
  workflowGetToolExecutions: (sessionId, limit) => ipcRenderer.invoke("workflow:getToolExecutions", sessionId, limit),
  workflowBroadcastIntervention: (sessionId, level, message) => ipcRenderer.invoke("workflow:broadcastIntervention", sessionId, level, message),
  workflowGetSessionState: (sessionId) => ipcRenderer.invoke("workflow:getSessionState", sessionId),
  workflowPersistSession: (sessionId) => ipcRenderer.invoke("workflow:persistSession", sessionId),
  workflowCloseSession: (sessionId) => ipcRenderer.invoke("workflow:closeSession", sessionId),
  workflowGetAllAgents: () => ipcRenderer.invoke("workflow:getAllAgents"),
  eventsLog: (toolId, level, message, metadata, sessionId) => ipcRenderer.invoke("events:log", toolId, level, message, metadata, sessionId),
  eventsGet: (filters, limit) => ipcRenderer.invoke("events:get", filters, limit),
  eventsGetBySession: (sessionId, level, limit) => ipcRenderer.invoke("events:getBySession", sessionId, level, limit),
  eventsGetByTool: (toolId, limit) => ipcRenderer.invoke("events:getByTool", toolId, limit),
  eventsGetRecent: (limit) => ipcRenderer.invoke("events:getRecent", limit),
  eventsGetStats: (sessionId) => ipcRenderer.invoke("events:getStats", sessionId),
  eventsSearch: (searchTerm, sessionId, limit) => ipcRenderer.invoke("events:search", searchTerm, sessionId, limit),
  eventsClear: (sessionId) => ipcRenderer.invoke("events:clear", sessionId),
  eventsExport: (format, sessionId) => ipcRenderer.invoke("events:export", format, sessionId),
  eventsGetTimeline: (sessionId, granularity) => ipcRenderer.invoke("events:getTimeline", sessionId, granularity)
});
